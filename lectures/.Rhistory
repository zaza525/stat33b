# which() to eliminate NAs
dogs[which(above), ]
# which() to eliminate NAs
dogs[which(above), ]
Equivalent, using `subset()`:
```{r}
subset(dogs, weight > mean(weight, na.rm = TRUE))
```
With `subset()`, there's no need to use `$`, and the `NA`s are eliminated
automatically.
subset(dogs, weight > mean(weight, na.rm = TRUE))
library(ggplot2)
ggplot(dogs)
library(ggplot2)
library(ggplot2)
ggplot(dogs)
ggplot(dogs) + geom_point()
ggplot(dogs, aes(x = datadog, y = popularity)) + geom_point()
stores = readRDS("data/grocery/stores.rds")
```{r}
stores = readRDS("data/grocery/stores.rds")
items = readRDS("data/grocery/items.rds")
stores = readRDS("data/grocery/stores.rds")
stores = readRDS("data/grocery/stores.rds")
stores = readRDS("data/grocery/stores.rds")
stores = readRDS("grocery/stores.rds")
items = readRDS("grocery/items.rds")
inv = readRDS("grocery/inventory.rds")
stores
inv
merge(items, inv)
stores = readRDS("grocery/stores.rds")
items = readRDS("grocery/items.rds")
inv = readRDS("grocery/inventory.rds")
stores
inv
items
x = 7
if (x > 5)
message("hello!")
if (x > 5) {
message("hello!")
message("x is greater than 5!")
}
if (x < 5) message("x is less than 5!") else message("x is greater than 5!")
if (x < 5)
message("x is less than 5!") else
message("x is greater than 5!")
# Using curly braces:
if (x < 5) {
message("x is less than 5!")
} else {
message("x is greater than 5!")
}
if (x < 5) {
message("hello!")
message("x is less than 5!")
} else if (x %% 2 == 0) { # if x is even
message("x is even!")
} else {
message("x is greater than or equal to 5, and odd!")
}
if (x < 5) {
message("hello!")
message("x is less than 5!")
} else if (x %% 2 == 0) { # if x is even
message("x is even!")
} else {
message("x is greater than or equal to 5, and odd!")
}
x = 28
y = if (x < 5) 42 else 8
y = if (x < 5) 42 # else NULL
y = if (x < 5) {
47
32
31
}
y = {
61
32
51
}
x = 28
y = if (x < 5) 42 else 8
y = if (x < 5) 42 # else NULL
y = if (x < 5) {
47
32
31
}
y = {
61
32
51
}
x = 28
y = if (x < 5) 42 else 8
y = if (x < 5) 42 # else NULL
y = if (x < 5) {
47
32
31
}
y = {
61
32
51
}
x = c(1, 2, 3)
if (x < 2) {
message("x is less than 2!")
}
ifelse(x < 2, x, 10)
ifelse(x < 2, x, 10)
x = c(1, 2, 3)
if (x < 2) {
message("x is less than 2!")
}
ifelse(x < 2, x, 10)
x = c(1, 2, 3)
if (x < 2) {
message("x is less than 2!")
}
ifelse(x < 2, x, 10)
x = c(1, 2, 3)
if (x < 2) {
message("x is less than 2!")
}
ifelse(x < 2, x, 10)
ifelse(x < 2, x, 10)
x = c(1, 2, 3)
if (x < 2) {
message("x is less than 2!")
}
ifelse(x < 2, x, 10)
ifelse(x < 2, x, 10)
ifelse(x < 2, x, 10)
ifelse(x < 2, x, 10)
ifelse(x < 2, x, 10)
message(ifelse(x < 2, x, 10))
message(ifelse(x < 2,9, x,9,  10))
message(ifelse(x < 2, x, 10))
```{r}
# With a string:
x = "33b"
switch(x,
"hello" = message("You said hello!"),
"bye" = {
message("Leaving so soon?")
message("I hoped you'd stay")
},
# Default case
message("Your variable didn't match")
)
# With an integer, matches by position:
x = 1
switch(x,
message("x is 1"),
message("x is 2"))
switch(x,
"hello" = message("You said hello!"),
"bye" = {
message("Leaving so soon?")
message("I hoped you'd stay")
},
# Default case
message("Your variable didn't match")
)
# With an integer, matches by position:
x = 1
# With a string:
x = "33b"
switch(x,
"hello" = message("You said hello!"),
"bye" = {
message("Leaving so soon?")
message("I hoped you'd stay")
},
# Default case
message("Your variable didn't match")
)
# With an integer, matches by position:
x = 1
switch(x,
message("x is 1"),
message("x is 2"))
# With a string:
x = "hello"
switch(x,
"hello" = message("You said hello!"),
"bye" = {
message("Leaving so soon?")
message("I hoped you'd stay")
},
# Default case
message("Your variable didn't match")
)
# With a string:
x = "bye"
switch(x,
"hello" = message("You said hello!"),
"bye" = {
message("Leaving so soon?")
message("I hoped you'd stay")
},
# Default case
message("Your variable didn't match")
)
switch(x, 20, 25)
switch(x, 20, 25)
mycases = list(20, 25)
mycases[[x]]
# Only 20 is evaluated:
#
#   switch(x, 20, time_consuming_function())
#
# Both 20 and time_consuming_function() are evaluated:
#
#   list(20, time_consuming_function())
#
switch(x, 20, 25)
sin(c(1, 2, 3))
mydata = list(c(1:3, NA), seq(10, 20, 0.5), rnorm(10))
mean(mydata[[1]], na.rm = TRUE)
mean(mydata[[2]])
lapply(mydata, mean, na.rm = TRUE)
lapply(c(1, 2, 3), sin) # vectorization would be better
lapply(c(1, 2, 3), sin) # vectorization would be better
dogs = readRDS("data/dogs/dogs_full.rds")
dogs = readRDS("dogs_full.rds")
# lapply() keeps the names of the input
lapply(dogs, class)
dogs = readRDS("dogs_full.rds")
# lapply() keeps the names of the input
lapply(dogs, class)
dogs = readRDS("dogs_full.rds")
# lapply() keeps the names of the input
lapply(dogs, class)
Most apply functions will accept additional arguments to the applied
function. These arguments are held constant across all elements of
the data:
```{r}
sapply(dogs, class)
sapply(mydata, mean, na.rm = c(TRUE, FALSE, FALSE))
sapply(mydata, mean, na.rm = c(TRUE, FALSE, FALSE))
sapply(mydata, mean, na.rm = c(TRUE, FALSE, FALSE))
`vapply()` simplifies the result to a vector of a specific type:
```{r}
vapply(dogs, class, "")
```
"v" is for **vector** result.
`mapply()` applies a function to each element of multiple vectors or
lists:
```{r}
x = 1:3
y = 2:4
x + y
# Same thing, less efficiently:
mapply(`+`, x, y)
# A better example:
mydata1 = list(1:3, 4:6)
mydata2 = list(4, 5:10)
mapply(sum, mydata1, mydata2)
# Another example:
missing = list(1:2, c(1:3, NA), c(1:4, NA))
na.rm = c(TRUE, FALSE, TRUE)
mapply(mean, missing, na.rm = na.rm)
# Another example:
missing = list(1:2, c(1:3, NA), c(1:4, NA))
na.rm = c(TRUE, FALSE, TRUE)
mapply(mean, missing, na.rm = na.rm)
# Another example:
missing = list(1:2, c(1:3, NA), c(1:4, NA))
na.rm = c(TRUE, FALSE, TRUE)
mapply(mean, missing, na.rm = na.rm)
---
_This is where the lecture ended. I've included the rest of the notes on loops
for anyone that wants to read ahead. The examples here will not necessarily be
identical to the ones I use in the next lecture._
### Flashback to Data Analysis
The `split()` function splits a vector or data frame into groups
based on some other vector.
Split weight of dogs by the group column:
```{r}
split(dogs$weight, dogs$group)
```
split(dogs$weight, dogs$group)
split(dogs$weight, dogs$group)
The `split()` function is especially useful when combined with
`lapply()` or `sapply`().
```{r}
split(dogs$weight, dogs$group)
by_group = split(dogs$weight, dogs$group)
sapply(by_group, mean, na.rm = TRUE)
by_group = split(dogs$weight, dogs$group)
sapply(by_group, mean, na.rm = TRUE)
```{r}
The `tapply()` function is equivalent to the `split()` and `sapply()`
idiom:
```{r}
tapply(dogs$weight, dogs$group, mean, na.rm = TRUE)
```
"t" for **table**, because `tapply()` is a generalization of the
frequency-counting function `table()`.
The `split()` and `tapply()` functions are important for analyzing
data in data frames.
### Other Apply Functions
* `apply()` applies a function to rows, columns, or elements of a
matrix, and returns a matrix.
* `eapply()` applies a function to the elements of an environment.
We'll learn about environments in a later lecture.
* `rapply()` applies a function to all elements of a recursive list
(a list of lists).
See this StackOverflow Post for a good summary:
https://stackoverflow.com/a/7141669
`for`, `while`, and `repeat`
----------------------
A for-loop runs a block of code once for each element of a vector or
list:
```{r}
for (i in 1:10) {
message(i)
}
```
The same idea as for-loops in other languages.
A while-loop runs a block of code repeatedly as long as some
condition is true:
```{r}
i = 1
while (i < 10) {
message(i)
i = i + 1
}
```
Again, the same idea as in other languages.
for (i in 1:10) {
message(i)
}
x = lapply(1:10, message)
# Fibonacci: 1 1 2 3 5 8 13 ...
n = 15
fib = c(1, 1)
for (i in 3:n) {
fib[i] = fib[i - 1] + fib[i - 2]
}
x = 4
if (x < 2)  message("Hi") else message("Bye")
y = if (x < 2) "Hi" else "Bye"
y
data1 = list(1:3, 5:8)
data2 = list(3)
sum(data1[[1]], data2[[1]])
sum(data1[[2]], data2[[2]])
data1 = list(1:3, 5:8)
data2 = list(3)
sum(data1[[1]], data2[[1]])
sum(data1[[2]], data2[[2]])
dogs = readRDS("data/dogs/dogs_full.rds")
by_group = split(dogs$weight, dogs$group)
sapply(by_group, median, na.rm = TRUE)
tapply(dogs$weight, dogs$group, median, na.rm = TRUE)
for (i in 1:10) {
message(i)
}
x = lapply(1:10, message)
# Fibonacci: 1 1 2 3 5 8 13 ...
n = 15
fib = c(1, 1)
for (i in 3:n) {
fib[i] = fib[i - 1] + fib[i - 2]
}
for (i in 1:10) {
message(i)
}
x = lapply(1:10, message)
x = lapply(1:10, message)
n = 15
fib = c(1, 1)
for (i in 3:n) {
fib[i] = fib[i - 1] + fib[i - 2]
}
n = 15
fib = c(1, 1)
for (i in 3:n) {
fib[i] = fib[i - 1] + fib[i - 2]
}
n = 15
fib = c(1, 1)
for (i in 3:n) {
fib[i] = fib[i - 1] + fib[i - 2]
}
A while-loop runs a block of code repeatedly as long as some
condition is true:
```{r}
n = 15
fib = c(1, 1)
i = 3
while (i <= n) {
fib[i] = fib[i - 1] + fib[i - 2]
i = i + 1
}
```
Again, the same idea as in other languages.
Use `break` to exit a loop early:
```{r}
for (i in 1:10) {
if (i %% 3 == 0) {
message("Stopped")
message(i)
break
}
}
```
for (i in 1:10) {
if (i %% 3 == 0) {
message("Stopped")
message(i)
break
}
}
for (i in 1:10) {
if (i %% 3 == 0) {
message("Div 3")
next
}
message(i)
}
n = 15
fib = c(1, 1)
i = 2
repeat {
i = i + 1
fib[i] = fib[i - 1] + fib[i - 2]
if (i >= n)
break
}
n = 15
fib = c(1, 1)
i = 2
repeat {
i = i + 1
fib[i] = fib[i - 1] + fib[i - 2]
if (i >= n)
break
}
n = 15
fib = numeric(n)
fib[1:2] = 1
for (i in 3:n) {
fib[i] = fib[i - 1] + fib[i - 2]
}
1:0
x = numeric(0)
1:length(x)
for (i in seq_along(x)) {
message(x[i])
}
hi = function() {
message("Hi")
}
hi()
square = function(x) x^2
square(7)
square(c(5, 6, 7))
cube = function(x) {
x^3
}
cube(c(-1, 1, 2))
square(7)
square(c(5, 6, 7))
cube = function(x) {
x^3
}
cube(c(-1, 1, 2))
cube0 = function(x) {
if (x == 0)
return (42)
x^3
}
cube0(0)
cube0 = function(x = -1) {
if (x == 0)
return (42)
x^3
}
cube0()
# Compute nth element of Fibonacci
find_fib = function(n = 15) {
if (n %in% c(1, 2))
return(1)
find_fib(n - 1) + find_fib(n - 2)
}
find_fib(15)
foo = function(n = 15) {
if (n %in% c(1, 2))
return(1)
Recall(n - 1) + Recall(n - 2)
}
foo(15)
f = function(x) 42
f(message("Hi!"))
f = function(x) {
force(x)
42
}
f(message("Hi!"))
add = function(x, y = x) {
x + y
}
add(2)
add(2, 3)
